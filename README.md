## 동시성 제어 방식 분석

### 1. synchronized 키워드

- **장점**:
    - **간단함**: 사용이 간단하며, JVM이 자동으로 잠금을 관리합니다.
    - **안전성**: 잠금이 자동으로 해제되므로, 잠금 누락으로 인한 문제가 발생하지 않습니다.
- **단점**:
    - **공정성 부족**: 스레드가 잠금을 획득하는 순서를 보장하지 않습니다.
    - **유연성 부족**: `ReentrantLock`에 비해 기능이 제한적입니다.

### 2. ReentrantLock

- **장점**:
  - **공정성 옵션**: `ReentrantLock`은 공정성(fairness) 옵션을 제공하여, 대기 중인 스레드가 공정하게 잠금을 획득할 수 있도록 합니다.
  - **유연성**: `synchronized` 키워드보다 더 많은 기능을 제공하며, 잠금을 해제하는 시점을 명시적으로 제어할 수 있습니다.
  - **조건 객체**: `Condition` 객체를 사용하여 보다 정교한 스레드 협력을 구현할 수 있습니다.
- **단점**:
  - **복잡성**: `synchronized`보다 사용이 복잡하며, 잠금을 명시적으로 해제해야 하므로 실수로 인한 잠금 누락이 발생할 수 있습니다.
  - **성능**: 잠금 획득과 해제에 대한 오버헤드가 있을 수 있습니다.

    
### 3. ConcurrentHashMap

- **장점**:
  - **성능**: 여러 스레드가 동시에 읽고 쓸 수 있도록 설계되어, 성능이 우수합니다.
  - **비차단**: 대부분의 읽기 작업이 비차단으로 수행됩니다.
- **단점**:
  - **복잡성**: 특정 상황에서는 `synchronized`보다 복잡할 수 있습니다.
  - **제한된 기능**: `ReentrantLock`이나 `synchronized`보다 기능이 제한적입니다.

### 결론

본 프로젝트에서는 `ReentrantLock`과 `ConcurrentHashMap`을 사용하여 사용자 ID를 활용해 Lock을 관리해 동일한 사용자에 대한 요청이 순차적으로 처리되도록 보장합니다. 
또한 비동기 처리를 통해 성능을 향상시키고, `CompletableFuture`를 사용하여 비동기 작업의 결과를 처리하였습니다.

### 비동기 처리를 통한 성능 개선 결과

| 테스트 번호 | 테스트 설명                                      | 기존 소요 시간 | 개선 후 소요 시간 |
|-------------|--------------------------------------------------|----------|------------------|
| 1번 테스트  | 특정 사용자가 동시에 1000포인트를 10회 충전한다. | 7.391s   | 3.335s           |
| 2번 테스트  | 특정 사용자가 동시에 500포인트를 100회 사용한다. | 40.895s  | 27.600s          |

### 기타
만약 DB, Redis, Kafka와 같은 외부 의존성이 커지게 되면 비관적 락/낙관적 락, Redis를 활용한 분산락, Kafka를 활용한 순서 보장 등의 방법 등을 활용할 수 있습니다.
